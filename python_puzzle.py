# -*- coding: utf-8 -*-
"""python puzzle.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YlWM0ehAcUJcupD14zoWWTPwcc71UmeN
"""

class Symbol:
    """A logical propositional symbol."""
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return self.name


class And:
    """A logical AND operator."""
    def __init__(self, *args):
        self.args = args

    def __repr__(self):
        return f"And({', '.join(map(str, self.args))})"


class Or:
    """A logical OR operator."""
    def __init__(self, *args):
        self.args = args

    def __repr__(self):
        return f"Or({', '.join(map(str, self.args))})"


class Not:
    """A logical NOT operator."""
    def __init__(self, operand):
        self.operand = operand

    def __repr__(self):
        return f"Not({self.operand})"


class Implication:
    """A logical Implication operator."""
    def __init__(self, antecedent, consequent):
        self.antecedent = antecedent
        self.consequent = consequent

    def __repr__(self):
        return f"Implication({self.antecedent}, {self.consequent})"


class Biconditional:
    """A logical Biconditional operator."""
    def __init__(self, left, right):
        self.left = left
        self.right = right

    def __repr__(self):
        return f"Biconditional({self.left}, {self.right})"


# Model-checking function
def model_check(knowledge, query):
    """Returns True if knowledge entails query, False otherwise."""
    from itertools import product

    # Extract all symbols from the knowledge base and query
    def extract_symbols(expression):
        if isinstance(expression, Symbol):
            return {expression}
        elif isinstance(expression, (And, Or)):
            symbols = set()
            for arg in expression.args:
                symbols.update(extract_symbols(arg))
            return symbols
        elif isinstance(expression, Not):
            return extract_symbols(expression.operand)
        elif isinstance(expression, Implication):
            return extract_symbols(expression.antecedent).union(
                extract_symbols(expression.consequent)
            )
        elif isinstance(expression, Biconditional):
            return extract_symbols(expression.left).union(
                extract_symbols(expression.right)
            )
        else:
            return set()

    symbols = list(extract_symbols(And(knowledge, query)))

    # Evaluate the expression under a specific model
    def evaluate(expression, model):
        if isinstance(expression, Symbol):
            return model[expression]
        elif isinstance(expression, Not):
            return not evaluate(expression.operand, model)
        elif isinstance(expression, And):
            return all(evaluate(arg, model) for arg in expression.args)
        elif isinstance(expression, Or):
            return any(evaluate(arg, model) for arg in expression.args)
        elif isinstance(expression, Implication):
            return not evaluate(expression.antecedent, model) or evaluate(
                expression.consequent, model
            )
        elif isinstance(expression, Biconditional):
            return evaluate(expression.left, model) == evaluate(expression.right)
        else:
            return False

    # Generate all possible models
    for values in product([False, True], repeat=len(symbols)):
        model = dict(zip(symbols, values))

        # Check if the model satisfies the knowledge base
        if evaluate(knowledge, model):
            # If the knowledge base is satisfied, check the query
            if not evaluate(query, model):
                return False

    return True


# Define propositional symbols for each character being a knight or a knave
AKnight = Symbol("A is a Knight")
AKnave = Symbol("A is a Knave")
BKnight = Symbol("B is a Knight")
BKnave = Symbol("B is a Knave")
CKnight = Symbol("C is a Knight")
CKnave = Symbol("C is a Knave")


# Puzzle 0
# A says "I am both a knight and a knave."
knowledge0 = And(
    Or(AKnight, AKnave),
    Not(And(AKnight, AKnave)),
    Implication(AKnight, And(AKnight, AKnave)),
    Implication(AKnave, Not(And(AKnight, AKnave)))
)

# Puzzle 1
# A says "We are both knaves."
# B says nothing.
knowledge1 = And(
    Or(AKnight, AKnave),
    Not(And(AKnight, AKnave)),
    Or(BKnight, BKnave),
    Not(And(BKnight, BKnave)),
    Implication(AKnight, And(AKnave, BKnave)),
    Implication(AKnave, Not(And(AKnave, BKnave)))
)

# Puzzle 2
# A says "We are the same kind."
# B says "We are of different kinds."
knowledge2 = And(
    Or(AKnight, AKnave),
    Not(And(AKnight, AKnave)),
    Or(BKnight, BKnave),
    Not(And(BKnight, BKnave)),
    Implication(AKnight, Or(And(AKnight, BKnight), And(AKnave, BKnave))),
    Implication(AKnave, Not(Or(And(AKnight, BKnight), And(AKnave, BKnave)))),
    Implication(BKnight, Or(And(AKnight, BKnave), And(AKnave, BKnight))),
    Implication(BKnave, Not(Or(And(AKnight, BKnave), And(AKnave, BKnight))))
)

# Puzzle 3
# A says "I am a knight" or "I am a knave."
# B says "A said 'I am a knave.'" and "C is a knave."
# C says "A is a knight."
knowledge3 = And(
    Or(AKnight, AKnave),
    Not(And(AKnight, AKnave)),
    Or(BKnight, BKnave),
    Not(And(BKnight, BKnave)),
    Or(CKnight, CKnave),
    Not(And(CKnight, CKnave)),
    Implication(AKnight, AKnight),
    Implication(AKnave, Not(AKnight)),
    Implication(BKnight, And(Implication(AKnight, AKnave), CKnave)),
    Implication(BKnave, Or(Not(Implication(AKnight, AKnave)), Not(CKnave))),
    Implication(CKnight, AKnight),
    Implication(CKnave, Not(AKnight))
)

# Function to check the models for each puzzle
def main():
    symbols = [AKnight, AKnave, BKnight, BKnave, CKnight, CKnave]
    puzzles = [
        ("Puzzle 0", knowledge0),
        ("Puzzle 1", knowledge1),
        ("Puzzle 2", knowledge2),
        ("Puzzle 3", knowledge3),
    ]

    for name, knowledge in puzzles:
        print(name)
        for symbol in symbols:
            if model_check(knowledge, symbol):
                print(f"    {symbol}")


# Run the main function
if __name__ == "__main__":
    main()

class Symbol:
    """A logical propositional symbol."""
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return self.name


class And:
    """A logical AND operator."""
    def __init__(self, *args):
        self.args = args

    def __repr__(self):
        return f"And({', '.join(map(str, self.args))})"


class Or:
    """A logical OR operator."""
    def __init__(self, *args):
        self.args = args

    def __repr__(self):
        return f"Or({', '.join(map(str, self.args))})"


class Not:
    """A logical NOT operator."""
    def __init__(self, operand):
        self.operand = operand

    def __repr__(self):
        return f"Not({self.operand})"


class Implication:
    """A logical Implication operator."""
    def __init__(self, antecedent, consequent):
        self.antecedent = antecedent
        self.consequent = consequent

    def __repr__(self):
        return f"Implication({self.antecedent}, {self.consequent})"


class Biconditional:
    """A logical Biconditional operator."""
    def __init__(self, left, right):
        self.left = left
        self.right = right

    def __repr__(self):
        return f"Biconditional({self.left}, {self.right})"


# Model-checking function
def model_check(knowledge, query):
    """Returns True if knowledge entails query, False otherwise."""
    from itertools import product

    # Extract all symbols from the knowledge base and query
    def extract_symbols(expression):
        if isinstance(expression, Symbol):
            return {expression}
        elif isinstance(expression, (And, Or)):
            symbols = set()
            for arg in expression.args:
                symbols.update(extract_symbols(arg))
            return symbols
        elif isinstance(expression, Not):
            return extract_symbols(expression.operand)
        elif isinstance(expression, Implication):
            return extract_symbols(expression.antecedent).union(
                extract_symbols(expression.consequent)
            )
        elif isinstance(expression, Biconditional):
            return extract_symbols(expression.left).union(
                extract_symbols(expression.right)
            )
        else:
            return set()

    symbols = list(extract_symbols(And(knowledge, query)))

    # Evaluate the expression under a specific model
    def evaluate(expression, model):
        if isinstance(expression, Symbol):
            return model[expression]
        elif isinstance(expression, Not):
            return not evaluate(expression.operand, model)
        elif isinstance(expression, And):
            return all(evaluate(arg, model) for arg in expression.args)
        elif isinstance(expression, Or):
            return any(evaluate(arg, model) for arg in expression.args)
        elif isinstance(expression, Implication):
            return not evaluate(expression.antecedent, model) or evaluate(
                expression.consequent, model
            )
        elif isinstance(expression, Biconditional):
            return evaluate(expression.left, model) == evaluate(expression.right)
        else:
            return False

    # Generate all possible models
    for values in product([False, True], repeat=len(symbols)):
        model = dict(zip(symbols, values))

        # Check if the model satisfies the knowledge base
        if evaluate(knowledge, model):
            # If the knowledge base is satisfied, check the query
            if not evaluate(query, model):
                return False

    return True


# Define propositional symbols for each character being a knight or a knave
AKnight = Symbol("A is a Knight")
AKnave = Symbol("A is a Knave")
BKnight = Symbol("B is a Knight")
BKnave = Symbol("B is a Knave")
CKnight = Symbol("C is a Knight")
CKnave = Symbol("C is a Knave")

# Puzzle 0
knowledge0 = And(
    Or(AKnight, AKnave),
    Not(And(AKnight, AKnave)),
    Implication(AKnight, And(AKnight, AKnave)),
    Implication(AKnave, Not(And(AKnight, AKnave)))
)

# Puzzle 1
knowledge1 = And(
    Or(AKnight, AKnave),
    Not(And(AKnight, AKnave)),
    Or(BKnight, BKnave),
    Not(And(BKnight, BKnave)),
    Implication(AKnight, And(AKnave, BKnave)),
    Implication(AKnave, Not(And(AKnave, BKnave)))
)

# Puzzle 2
knowledge2 = And(
    Or(AKnight, AKnave),
    Not(And(AKnight, AKnave)),
    Or(BKnight, BKnave),
    Not(And(BKnight, BKnave)),
    Implication(AKnight, Or(And(AKnight, BKnight), And(AKnave, BKnave))),
    Implication(AKnave, Not(Or(And(AKnight, BKnight), And(AKnave, BKnave)))),
    Implication(BKnight, Or(And(AKnight, BKnave), And(AKnave, BKnight))),
    Implication(BKnave, Not(Or(And(AKnight, BKnave), And(AKnave, BKnight))))
)

# Puzzle 3
knowledge3 = And(
    Or(AKnight, AKnave),
    Not(And(AKnight, AKnave)),
    Or(BKnight, BKnave),
    Not(And(BKnight, BKnave)),
    Or(CKnight, CKnave),
    Not(And(CKnight, CKnave)),
    Implication(AKnight, AKnight),
    Implication(AKnave, Not(AKnight)),
    Implication(BKnight, And(Implication(AKnight, AKnave), CKnave)),
    Implication(BKnave, Or(Not(Implication(AKnight, AKnave)), Not(CKnave))),
    Implication(CKnight, AKnight),
    Implication(CKnave, Not(AKnight))
)

# Main function to check the models for each puzzle
def main():
    symbols = [AKnight, AKnave, BKnight, BKnave, CKnight, CKnave]
    puzzles = [
        ("Puzzle 0", knowledge0),
        ("Puzzle 1", knowledge1),
        ("Puzzle 2", knowledge2),
        ("Puzzle 3", knowledge3),
    ]

    for name, knowledge in puzzles:
        print(name)
        for symbol in symbols:
            if model_check(knowledge, symbol):
                print(f"    {symbol}")


if __name__ == "__main__":
    main()



